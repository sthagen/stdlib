#!/usr/bin/env bash
#
# @license Apache-2.0
#
# Copyright (c) 2020 The Stdlib Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

## USER-DEFINED VARIABLES ##

# Define the main export alias:
ALIAS='diracDelta'

# Define the package description:
PKG_DESC='Evaluate the Dirac delta function for each element in a strided array.'

# Define the module description:
# shellcheck disable=SC2016
MODULE_DESC='Evaluate the Dirac delta function for each element in a strided array `x` and assign the results to elements in a strided array `y`.'

# Define main export description:
# shellcheck disable=SC2016
MAIN_DESC='Evaluates the Dirac delta function for each element in a strided array `x` and assigns the results to elements in a strided array `y`.'

# Define the test description:
TEST_DESC='evaluates the Dirac delta function for each element'

# Define a list of keywords:
KEYWORDS=(
    "stdmath"
    "mathematics"
    "math"
    "dirac"
    "delta"
    "distribution"
    "dist"
    "continuous"
    "kronecker"
    "spike"
    "impulse"
)

# Define the minimum value of generated values when benchmarking and testing the implementation:
RAND_MIN='-100.0'

# Define the maximum value of generated values when benchmarking and testing the implementation:
RAND_MAX='100.0'

# Define lists of input array values:
X_VALUES_LEN_8=(
	'-4.0'
	'-3.0'
	'-2.0'
	'-1.0'
	'0.0'
	'1.0'
	'2.0'
	'3.0'
)


## COMPUTED VARIABLES ##

# Converts from camel case to a underscored delineated string.
#
# $1 - string to convert
camelcase_to_snakecase() {
	echo "$1" | sed 's/\([^A-Z]\)\([A-Z]\)/\1_\2/g' | sed 's/\([A-Z]\)\([A-Z]\)\([^A-Z]\)/\1_\2\3/g' | tr '[:upper:]' '[:lower:]'
}

# Convert the alias to snakecase:
ALIAS_SNAKECASE=$(camelcase_to_snakecase "${ALIAS}")

# Define the destination package alias:
PKG_ALIAS="${ALIAS_SNAKECASE//_/-}"

# Define the destination package parent directory path:
PKG_PATH="stdlib/math/strided/special"

# Define the full destination package name:
PKG="${PKG_PATH}/${PKG_ALIAS}"

# Determine the root project directory:
root_dir="$(git rev-parse --show-toplevel)"

# Define the project source code directory:
base_dir="${root_dir}/lib/node_modules"

# Define the destination path:
dest_dir="${base_dir}/@${PKG}"

# Define the location of this scaffold:
this_dir="${base_dir}/@stdlib/_tools/scaffold/strided-unary"

# Define the location of a utility for wrapping REPL text descriptions:
wrap="${base_dir}/@stdlib/_tools/repl-txt/wrap-desc/bin/cli"

# Define the unary function alias:
UNARY_ALIAS="${ALIAS}"

# Convert the unary function alias to snakecase:
UNARY_ALIAS_SNAKECASE=$(camelcase_to_snakecase "${UNARY_ALIAS}")

# Define the unary package "alias":
UNARY_PKG_ALIAS="${UNARY_ALIAS_SNAKECASE//_/-}"

# Define the unary package parent directory path:
UNARY_PKG_PATH="stdlib/math/base/special"

# Define the package containing the unary function to apply:
UNARY_PKG="${UNARY_PKG_PATH}/${UNARY_PKG_ALIAS}"

# Define the unary package include path:
UNARY_PKG_INCLUDE="${UNARY_PKG_PATH}/${UNARY_ALIAS_SNAKECASE}"

# Define the typed array data type:
TYPED_ARRAY_DTYPE='float64'

# Define the typed array constructor:
TYPED_ARRAY_CTOR="$(echo ${TYPED_ARRAY_DTYPE:0:1} | tr '[:lower:]' '[:upper:]')${TYPED_ARRAY_DTYPE:1}Array"

# Define the ndarray method description:
# shellcheck disable=SC2001
NDARRAY_DESC=$(echo "${MAIN_DESC}" | sed 's/\.$//')
NDARRAY_DESC="${NDARRAY_DESC} using alternative indexing semantics."

# Define the REPL text main export description (note: 4 space indent and wrap at 80 characters):
REPL_TEXT_MAIN_DESC=$(echo -n "${MAIN_DESC}" | "${wrap}")
REPL_TEXT_MAIN_DESC="${REPL_TEXT_MAIN_DESC/    /}"

# Define the REPL text ndarray method description (note: 4 space indent and wrap at 80 characters):
REPL_TEXT_NDARRAY_DESC=$(echo -n "${NDARRAY_DESC}" | "${wrap}")
REPL_TEXT_NDARRAY_DESC="${REPL_TEXT_NDARRAY_DESC/    /}"

# Define the copyright year:
YEAR=$(date +'%Y')

# Define the copyright holders:
COPYRIGHT='The Stdlib Authors'

# Define lists of input array values:
X_VALUES_LEN_4=(
	"${X_VALUES_LEN_8[0]}"
	"${X_VALUES_LEN_8[1]}"
	"${X_VALUES_LEN_8[2]}"
	"${X_VALUES_LEN_8[3]}"
)
X_VALUES_LEN_5=("${X_VALUES_LEN_4[@]}" "${X_VALUES_LEN_8[4]}")
X_VALUES_LEN_6=("${X_VALUES_LEN_5[@]}" "${X_VALUES_LEN_8[5]}")

# Define lists of expected values:
expected_script="var roundn = require( '${base_dir}/@stdlib/math/base/special/roundn' );var isInteger = require( '${base_dir}/@stdlib/assert/is-integer' ).isPrimitive;var f = require( '${base_dir}/@${UNARY_PKG}' );var arr = '${X_VALUES_LEN_6[*]}'.split( ' ' );var expected = arr.slice();for ( var i = 0; i < arr.length; i++ ) {var v1 = f( parseFloat( arr[ i ] ) );var v2 = roundn( v1, -3 );if ( v1 == v2 ) {v = v1.toString();if ( isInteger( v1 ) ) {v += '.0';}} else {v = '~' + v2.toString();if ( isInteger( v2 ) ) {v += '.0';}}expected[ i ] = v;}console.log( expected.join( ',' ) );"

expected_len_6=$(node -e "${expected_script}")
IFS=','; read -ra EXPECTED_LEN_6 <<< "${expected_len_6}"; IFS=' ';
EXPECTED_LEN_4=(
	"${EXPECTED_LEN_6[0]}"
	"${EXPECTED_LEN_6[1]}"
	"${EXPECTED_LEN_6[2]}"
	"${EXPECTED_LEN_6[3]}"
)
EXPECTED_LEN_5=("${EXPECTED_LEN_4[@]}" "${EXPECTED_LEN_6[4]}")

# Expected values for X_VALUES_LEN_4 where `x` has stride `2` and `y` has stride `-1`:
EXPECTED_LEN_2_X2_YM1=("${EXPECTED_LEN_4[2]}" "${EXPECTED_LEN_4[0]}")

# Expected values for X_VALUES_LEN_4 starting at 2nd element and where `x` has stride `-2` and `y` has stride `1`:
EXPECTED_LEN_2_XM2_Y1=("${EXPECTED_LEN_4[3]}" "${EXPECTED_LEN_4[1]}")

# Expected values for X_VALUES_LEN_6 where `x` has stride `2` and `y` has stride `-1`:
EXPECTED_LEN_3_X2_YM1=("${EXPECTED_LEN_6[4]}" "${EXPECTED_LEN_2_X2_YM1[@]}")

# Expected values for X_VALUES_LEN_6 starting at 2nd element and where `x` has stride `-2` and `y` has stride `1`:
EXPECTED_LEN_3_XM2_Y1=("${EXPECTED_LEN_6[5]}" "${EXPECTED_LEN_2_XM2_Y1[@]}")


## SCRIPT ##

# Define the list of scaffold directories:
dirs=(
	"benchmark"
	"docs"
	"docs/types"
	"examples"
	"lib"
	"src"
	"test"
)

# Define the list of scaffold files:
files=(
	"benchmark/benchmark.js"
	"benchmark/benchmark.native.js"
	"benchmark/benchmark.ndarray.js"
	"benchmark/benchmark.ndarray.native.js"
	"docs/types/index.d.ts"
	"docs/types/test.ts"
	"docs/repl.txt"
	"examples/index.js"
	"lib/alias.js"
	"lib/alias.native.js"
	"lib/data.js"
	"lib/index.js"
	"lib/main.js"
	"lib/meta.json"
	"lib/native.js"
	"lib/ndarray.js"
	"lib/ndarray.native.js"
	"lib/props.js"
	"lib/types.json"
	"src/addon.c"
	"src/Makefile"
	"test/test.alias.js"
	"test/test.alias.native.js"
	"test/test.js"
	"test/test.ndarray.js"
	"test/test.ndarray.native.js"
	"binding.gyp"
	"include.gypi"
	"manifest.json"
	"package.json"
	"README.md"
)

# Create the destination directories...

for dir in ${dirs[*]}; do
	mkdir -p "${dest_dir}/${dir}"
done

# Copy the scaffold files to the destination directory...
for file in ${files[*]}; do
	if echo "${file}" | grep -q "alias"; then
		cp "${this_dir}/data/${file}" "${dest_dir}/${file/alias/${ALIAS_SNAKECASE}}"
	else
		cp "${this_dir}/data/${file}" "${dest_dir}/${file}"
	fi
done

# Performs a find and replace across the destination directory.
#
# $1 - regular expression
find_and_replace() {
	find "${dest_dir}" -type f -print0 | xargs -0 perl -pi -w -e "$1"
}

# Performs a find and replace across a specified file.
#
# $1 - file
# $2 - regular expression
file_find_and_replace() {
	find "${dest_dir}/$1" -type f -print0 | xargs -0 perl -pi -w -e "$2"
}

# Joins a list of strings.
#
# $1 - separator
# $* - list of strings to join
join() {
	local d=$1; shift; local f=$1; shift; printf %s "$f" "${@/#/$d}";
}

# For each of the variables defined above, insert into the scaffold files...
regex="s/\\{\\{YEAR\\}\\}/${YEAR}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{COPYRIGHT\\}\\}/${COPYRIGHT}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{ALIAS\\}\\}/${ALIAS}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{ALIAS_SNAKECASE\\}\\}/${ALIAS_SNAKECASE}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{PKG\\}\\}/${PKG//\//\\/}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{PKG_DESC\\}\\}/${PKG_DESC}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{MODULE_DESC\\}\\}/${MODULE_DESC}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{MAIN_DESC\\}\\}/${MAIN_DESC}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{NDARRAY_DESC\\}\\}/${NDARRAY_DESC}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{TEST_DESC\\}\\}/${TEST_DESC}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{REPL_TEXT_MAIN_DESC\\}\\}/${REPL_TEXT_MAIN_DESC}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{REPL_TEXT_NDARRAY_DESC\\}\\}/${REPL_TEXT_NDARRAY_DESC}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{UNARY_PKG\\}\\}/${UNARY_PKG//\//\\/}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{UNARY_PKG_INCLUDE\\}\\}/${UNARY_PKG_INCLUDE//\//\\/}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{UNARY_ALIAS\\}\\}/${UNARY_ALIAS}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{UNARY_ALIAS_SNAKECASE\\}\\}/${UNARY_ALIAS_SNAKECASE}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{TYPED_ARRAY_CTOR\\}\\}/${TYPED_ARRAY_CTOR}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{TYPED_ARRAY_DTYPE\\}\\}/${TYPED_ARRAY_DTYPE}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{RAND_MIN\\}\\}/${RAND_MIN}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{RAND_MAX\\}\\}/${RAND_MAX}/g;"
find_and_replace "${regex}"

keywords_sep='",\n    "'
if [ "${#KEYWORDS[*]}" -eq 0 ]; then
	keywords=''
else
	keywords=$(join "${keywords_sep}" "${KEYWORDS[@]}")
	keywords="\\n    \"${keywords}\","
fi
regex="s/\\{\\{KEYWORDS\\}\\}/${keywords}/g;"
find_and_replace "${regex}"

expected_values_sep=', '

values=$(join "${expected_values_sep}" "${X_VALUES_LEN_4[@]}")
regex="s/\\{\\{X_VALUES_LEN_4\\}\\}/${values}/g;"
find_and_replace "${regex}"

values=$(join "${expected_values_sep}" "${X_VALUES_LEN_5[@]}")
regex="s/\\{\\{X_VALUES_LEN_5\\}\\}/${values}/g;"
find_and_replace "${regex}"

values=$(join "${expected_values_sep}" "${X_VALUES_LEN_6[@]}")
regex="s/\\{\\{X_VALUES_LEN_6\\}\\}/${values}/g;"
find_and_replace "${regex}"

values=$(join "${expected_values_sep}" "${X_VALUES_LEN_8[@]}")
regex="s/\\{\\{X_VALUES_LEN_8\\}\\}/${values}/g;"
find_and_replace "${regex}"

values=$(join "${expected_values_sep}" "${EXPECTED_LEN_4[@]}")
regex="s/\\{\\{EXPECTED_LEN_4\\}\\}/${values}/g;"
find_and_replace "${regex}"

values=$(join "${expected_values_sep}" "${EXPECTED_LEN_5[@]}")
regex="s/\\{\\{EXPECTED_LEN_5\\}\\}/${values}/g;"
find_and_replace "${regex}"

values=$(join "${expected_values_sep}" "${EXPECTED_LEN_2_X2_YM1[@]}")
regex="s/\\{\\{EXPECTED_LEN_2_X2_YM1\\}\\}/${values}/g;"
find_and_replace "${regex}"

values=$(join "${expected_values_sep}" "${EXPECTED_LEN_2_XM2_Y1[@]}")
regex="s/\\{\\{EXPECTED_LEN_2_XM2_Y1\\}\\}/${values}/g;"
find_and_replace "${regex}"

values=$(join "${expected_values_sep}" "${EXPECTED_LEN_3_X2_YM1[@]}")
regex="s/\\{\\{EXPECTED_LEN_3_X2_YM1\\}\\}/${values}/g;"
find_and_replace "${regex}"

values=$(join "${expected_values_sep}" "${EXPECTED_LEN_3_XM2_Y1[@]}")
regex="s/\\{\\{EXPECTED_LEN_3_XM2_Y1\\}\\}/${values}/g;"
find_and_replace "${regex}"
