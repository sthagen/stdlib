/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var isObject = require( '@stdlib/assert/is-plain-object' );
var isPositiveInteger = require( '@stdlib/assert/is-positive-integer' ).isPrimitive;
var hasOwnProp = require( '@stdlib/assert/has-own-property' );
var baseCtor = require( '@stdlib/ndarray/ctor' );
var defaults = require( './defaults.json' );
var getKey = require( './key.js' );
var cache = require( './cache.js' );


// VARIABLES //

var CACHE = cache();


// MAIN //

/**
* Returns a memoized ndarray constructor.
*
* @param {string} dtype - data type
* @param {PositiveInteger} ndims - number of dimensions
* @param {Options} [options] - function options
* @param {boolean} [options.codegen=true] - boolean indicating whether to use code generation
* @param {string} [options.mode="throw"] - specifies how to handle indices which exceed array dimensions
* @param {StringArray} [options.submode=["throw"]] - specifies how to handle subscripts which exceed array dimensions on a per dimension basis
* @throws {TypeError} first argument must be a supported ndarray data type
* @throws {TypeError} second argument must be a number having a positive integer value
* @throws {TypeError} options argument must be an object
* @throws {TypeError} must provide valid options
* @returns {Function} memoized ndarray constructor
*
* @example
* var f1 = ctor( 'float64', 3 );
* // returns <Function>
*
* var f2 = ctor( 'float64', 3 );
* // returns <Function>
*
* var bool = ( f1 === f2 );
* // returns true
*
* var buffer = [ 1, 2, 3, 4, 5, 6 ];
* var shape = [ 3, 2 ];
* var strides = [ 2, 1 ];
* var offset = 0;
*
* var out = f1( buffer, shape, strides, offset, 'row-major' );
*/
function ctor( dtype, ndims, options ) {
	var ctors;
	var opts;
	var key;
	var len;
	var f;
	var i;

	opts = {};
	if ( arguments.length > 2 ) {
		if ( !isObject( options ) ) {
			throw new TypeError( 'invalid argument. Options argument must be an object. Value: `' + options + '`.' );
		}
		if ( hasOwnProp( options, 'codegen' ) ) {
			opts.codegen = options.codegen;
		} else {
			opts.codegen = defaults.codegen;
		}
		if ( hasOwnProp( options, 'mode' ) ) {
			opts.mode = options.mode;
		} else {
			opts.mode = defaults.mode;
		}
		if ( hasOwnProp( options, 'submode' ) ) {
			opts.submode = options.submode;
		} else {
			opts.submode = [ opts.mode ];
		}
	} else {
		opts.codegen = defaults.codegen;
		opts.mode = defaults.mode;
		opts.submode = [ opts.mode ];
	}
	key = getKey( dtype, opts );
	ctors = CACHE[ key ];

	// If we didn't find any constructors, this could be due to 1) we have yet to create the constructor or 2) we have been provided invalid options. Either way, let's attempt to create an ndarray constructor...
	if ( ctors === void 0 ) {
		f = baseCtor( dtype, ndims, opts );

		// If the previous statement did not throw an error, we can cache the constructor...
		ctors = []; // Note: we use an array to avoid unordered key look-up
		for ( i = 0; i < ndims-1; i++ ) {
			ctors.push( false );
		}
		ctors.push( f );
		CACHE[ key ] = ctors;
		return f;
	}
	if ( !isPositiveInteger( ndims ) ) {
		throw new TypeError( 'invalid argument. Second argument must be a positive integer. Value: `' + ndims + '`.' );
	}
	// If the constructor has not already been created, create it; otherwise, return a memoized constructor...
	len = ctors.length;
	if ( ndims <= len ) {
		f = ctors[ ndims-1 ];
		if ( f === false ) {
			f = baseCtor( dtype, ndims, opts );
			ctors[ ndims-1 ] = f;
		}
	} else {
		f = baseCtor( dtype, ndims, opts );
		for ( i = len+1; i < ndims; i++ ) {
			ctors.push( false );
		}
		ctors.push( f );
	}
	return f;
}


// EXPORTS //

module.exports = ctor;
