/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

/* eslint-disable no-invalid-this */

'use strict';

// MODULES //

var setReadOnly = require( '@stdlib/utils/define-nonenumerable-read-only-property' );
var isCollection = require( '@stdlib/assert/is-array-like-object' );
var isNonNegativeIntegerArray = require( '@stdlib/assert/is-nonnegative-integer-array' ).primitives;
var isNonNegativeInteger = require( '@stdlib/assert/is-nonnegative-integer' ).isPrimitive;
var isIntegerArray = require( '@stdlib/assert/is-integer-array' ).primitives;
var isOrder = require( '@stdlib/ndarray/base/assert/is-order' );
var isDataType = require( '@stdlib/ndarray/base/assert/is-data-type' );
var isBufferLengthCompatible = require( '@stdlib/ndarray/base/assert/is-buffer-length-compatible' );
var parent = require( '@stdlib/ndarray/base/ctor' ); // eslint-disable-line stdlib/no-redeclare
var inherit = require( '@stdlib/utils/inherit' );
var defaults = require( './defaults.json' );
var iget = require( './iget.js' );
var iset = require( './iset.js' );
var get = require( './get.js' );
var set = require( './set.js' );
var copy = require( './copy_array.js' );
var validate = require( './validate.js' );


// VARIABLES //

/*
* See the following references:
*
* -  https://stackoverflow.com/questions/22747068/is-there-a-max-number-of-arguments-javascript-functions-can-accept
* -  https://bugs.webkit.org/show_bug.cgi?id=80797
* -  https://github.com/numpy/numpy/issues/5744
*
* Note that the maximum number of function arguments can vary from engine to engine. Here, we choose something of a lowest common denominator which may **not** be valid everywhere.
*/
var MAX_DIMS = 32767|0;


// MAIN //

/**
* ndarray constructor.
*
* @constructor
* @param {string} dtype - data type
* @param {(Collection|TypedArray|Buffer)} buffer - data buffer
* @param {NonNegativeIntegerArray} shape - array shape
* @param {IntegerArray} strides - array strides
* @param {NonNegativeInteger} offset - index offset
* @param {string} order - specifies whether an array is row-major (C-style) or column-major (Fortran-style)
* @param {Options} [options] - function options
* @param {string} [options.mode="throw"] - specifies how to handle indices which exceed array dimensions
* @param {StringArray} [options.submode=["throw"]] - specifies how to handle subscripts which exceed array dimensions on a per dimension basis
* @throws {TypeError} `dtype` argument must be a supported ndarray data type
* @throws {TypeError} `buffer` argument must be an array-like object, typed-array-like, or a Buffer
* @throws {TypeError} `shape` argument must be an array-like object containing nonnegative integers
* @throws {Error} `shape` argument length must equal the number of dimensions
* @throws {TypeError} `strides` argument must be an array-like object containing integers
* @throws {Error} `strides` argument length must equal the number of dimensions
* @throws {TypeError} `offset` argument must be a nonnegative integer
* @throws {TypeError} `order` argument must be a supported ndarray order
* @throws {Error} `buffer` argument must be compatible with specified meta data
* @throws {TypeError} options argument must be an object
* @throws {TypeError} must provide valid options
* @throws {RangeError} too many dimensions
* @returns {ndarray} ndarray instance
*
* @example
* var buffer = [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 ];
* var shape = [ 3, 2 ];
* var strides = [ 2, 1 ];
* var offset = 0;
*
* var out = ndarray( 'generic', buffer, shape, strides, offset, 'row-major' );
*/
function ndarray( dtype, buffer, shape, strides, offset, order, options ) {
	var ndims;
	var opts;
	var err;
	var sh;
	var st;

	if ( !(this instanceof ndarray) ) {
		if ( arguments.length < 7 ) {
			return new ndarray( dtype, buffer, shape, strides, offset, order );
		}
		return new ndarray( dtype, buffer, shape, strides, offset, order, options ); // eslint-disable-line max-len
	}
	if ( !isDataType( dtype ) ) {
		throw new TypeError( 'invalid argument. `dtype` argument must be a supported ndarray data type. Value: `' + dtype + '`.' );
	}
	if ( !isCollection( buffer ) ) {
		throw new TypeError( 'invalid argument. `buffer` argument must be an array-like object, typed-array-like, or a Buffer. Value: `' + buffer + '`.' );
	}
	if ( !isNonNegativeIntegerArray( shape ) ) {
		throw new TypeError( 'invalid argument. `shape` argument must be an array-like object containing nonnegative integers. Value: `' + shape + '`.' );
	}
	ndims = shape.length;
	if ( ndims > MAX_DIMS ) {
		throw new RangeError( 'invalid argument. Number of dimensions must not exceed ' + MAX_DIMS + ' due to stack limits. Value: `' + ndims + '`.' );
	}
	if ( !isIntegerArray( strides ) ) {
		throw new TypeError( 'invalid argument. `strides` argument must be an array-like object containing integers. Value: `' + strides + '`.' );
	}
	if ( strides.length !== ndims ) {
		throw new Error( 'invalid argument. `strides` length must match the number of dimensions. Expected number of dimensions: ' + ndims + '. Strides length: ' + strides.length + '.' );
	}
	if ( !isNonNegativeInteger( offset ) ) {
		throw new TypeError( 'invalid argument. `offset` argument must be a nonnegative integer. Value: `' + offset + '`.' );
	}
	if ( !isOrder( order ) ) {
		throw new TypeError( 'invalid argument. `order` argument must be a supported order. Value: `' + order + '`.' );
	}
	if ( !isBufferLengthCompatible( buffer.length, shape, strides, offset ) ) {
		throw new Error( 'invalid arguments. The input buffer is incompatible with the specified meta data. Ensure that the offset is valid with regard to the stride array and that the buffer has enough elements to satisfy the desired array shape.' );
	}
	opts = {};
	opts.mode = defaults.mode;
	if ( arguments.length > 6 ) {
		err = validate( opts, options );
		if ( err ) {
			throw err;
		}
	}
	this._mode = opts.mode;
	if ( opts.submode === void 0 ) {
		opts.submode = [ this._mode ];
	}
	this._submode = opts.submode;

	// Copy `shape` and `strides` to prevent external mutation:
	sh = copy( shape, ndims );
	st = copy( strides, ndims );

	// Call the parent constructor:
	parent.call( this, dtype, buffer, sh, st, offset, order );

	return this;

	/* eslint-enable no-invalid-this */
}

// Inherit from the parent constructor:
inherit( ndarray, parent );

/**
* Constructor name.
*
* @name name
* @memberof ndarray
* @type {string}
* @default 'ndarray'
*
* @example
* var str = ndarray.name;
* // returns 'ndarray'
*/
setReadOnly( ndarray, 'name', 'ndarray' );

/**
* Returns an array element.
*
* @name get
* @memberof ndarray.prototype
* @type {Function}
* @param {...integer} idx - indices
* @returns {*} array element
*
* @example
* var buffer = [ 1, 2, 3, 4, 5, 6 ];
* var shape = [ 3, 2 ];
* var strides = [ 2, 1 ];
* var offset = 0;
*
* var x = ndarray( 'generic', buffer, shape, strides, offset, 'row-major' );
*
* var v = x.get( 1, 1 );
* // returns 4
*/
setReadOnly( ndarray.prototype, 'get', get );

/**
* Returns an array element located at a specified linear index.
*
* @name iget
* @memberof ndarray.prototype
* @type {Function}
* @param {integer} idx - linear index
* @returns {*} array element
*
* @example
* var buffer = [ 1, 2, 3, 4, 5, 6 ];
* var shape = [ 3, 2 ];
* var strides = [ 2, 1 ];
* var offset = 0;
*
* var x = ndarray( 'generic', buffer, shape, strides, offset, 'row-major' );
*
* var v = x.iget( 3 );
* // returns 4
*/
setReadOnly( ndarray.prototype, 'iget', iget );

/**
* Sets an array element.
*
* @name set
* @memberof ndarray.prototype
* @type {Function}
* @param {...integer} idx - indices
* @param {*} v - value to set
* @returns {ndarray} ndarray instance
*
* @example
* var buffer = [ 1, 2, 3, 4, 5, 6 ];
* var shape = [ 3, 2 ];
* var strides = [ 2, 1 ];
* var offset = 0;
*
* var x = ndarray( 'generic', buffer, shape, strides, offset, 'row-major' );
*
* var v = x.get( 1, 1 );
* // returns 4
*
* x.set( 1, 1, 10 );
*
* var b = x.data;
* // returns [ 1, 2, 3, 10, 5, 6 ]
*
* v = x.get( 1, 1 );
* // returns 10
*/
setReadOnly( ndarray.prototype, 'set', set );

/**
* Sets an array element located at a specified linear index.
*
* @name iset
* @memberof ndarray.prototype
* @type {Function}
* @param {integer} idx - linear index
* @param {*} v - value to set
* @returns {ndarray} ndarray instance
*
* @example
* var buffer = [ 1, 2, 3, 4, 5, 6 ];
* var shape = [ 3, 2 ];
* var strides = [ 2, 1 ];
* var offset = 0;
*
* var x = ndarray( 'generic', buffer, shape, strides, offset, 'row-major' );
*
* var v = x.iget( 3 );
* // returns 4
*
* x.iset( 3, 10 );
*
* var b = x.data;
* // returns [ 1, 2, 3, 10, 5, 6 ]
*
* v = x.iget( 3 );
* // returns 10
*/
setReadOnly( ndarray.prototype, 'iset', iset );


// EXPORTS //

module.exports = ndarray;
