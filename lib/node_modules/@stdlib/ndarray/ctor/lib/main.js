/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var setReadOnly = require( '@stdlib/utils/define-nonenumerable-read-only-property' );
var isArrayLikeObject = require( '@stdlib/assert/is-array-like-object' );
var isTypedArrayLike = require( '@stdlib/assert/is-typed-array-like' );
var isBuffer = require( '@stdlib/assert/is-buffer' );
var isNonNegativeIntegerArray = require( '@stdlib/assert/is-nonnegative-integer-array' ).primitives;
var isNonNegativeInteger = require( '@stdlib/assert/is-nonnegative-integer' ).isPrimitive;
var isPositiveInteger = require( '@stdlib/assert/is-positive-integer' ).isPrimitive;
var isIntegerArray = require( '@stdlib/assert/is-integer-array' ).primitives;
var isOrder = require( '@stdlib/ndarray/base/assert/is-order' );
var isDataType = require( '@stdlib/ndarray/base/assert/is-data-type' );
var isBufferLengthCompatible = require( '@stdlib/ndarray/base/assert/is-buffer-length-compatible' );
var bytesPerElement = require( '@stdlib/ndarray/base/bytes-per-element' );
var baseCtor = require( '@stdlib/ndarray/base/memoized-ctor' );
var inherit = require( '@stdlib/utils/inherit' );
var defaults = require( './defaults.json' );
var igetValue = require( './iget.js' );
var isetValue = require( './iset.js' );
var getValue = require( './get.js' );
var setValue = require( './set.js' );
var copy = require( './copy_array.js' );
var validate = require( './validate.js' );


// VARIABLES //

/*
* See the following references:
*
* -  https://stackoverflow.com/questions/22747068/is-there-a-max-number-of-arguments-javascript-functions-can-accept
* -  https://bugs.webkit.org/show_bug.cgi?id=80797
* -  https://github.com/numpy/numpy/issues/5744
*
* Note that the maximum number of function arguments can vary from engine to engine. Here, we choose something of a lowest common denominator which may **not** be valid everywhere.
*/
var MAX_DIMS = 32767|0;


// MAIN //

/**
* Returns an ndarray constructor.
*
* @param {string} dtype - data type
* @param {PositiveInteger} ndims - number of dimensions
* @param {Options} [options] - function options
* @param {boolean} [options.codegen=true] - boolean indicating whether to use code generation
* @param {string} [options.mode="throw"] - specifies how to handle indices which exceed array dimensions
* @param {StringArray} [options.submode=["throw"]] - specifies how to handle subscripts which exceed array dimensions on a per dimension basis
* @throws {TypeError} first argument must be a supported ndarray data type
* @throws {TypeError} second argument must be a number having a positive integer value
* @throws {TypeError} options argument must be an object
* @throws {TypeError} must provide valid options
* @throws {RangeError} too many dimensions
* @returns {Function} ndarray constructor
*
* @example
* var ndarray = ctor( 'generic', 2 );
* // returns <Function>
*
* var buffer = [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 ];
* var shape = [ 3, 2 ];
* var strides = [ 2, 1 ];
* var offset = 0;
*
* var out = ndarray( buffer, shape, strides, offset, 'row-major' );
*/
function ctor( dtype, ndims, options ) {
	var parent;
	var opts;
	var err;

	if ( !isDataType( dtype ) ) {
		throw new TypeError( 'invalid argument. First argument must be a supported ndarray data type. Value: `' + dtype + '`.' );
	}
	if ( !isPositiveInteger( ndims ) ) {
		throw new TypeError( 'invalid argument. Second argument must be a positive integer. Value: `' + ndims + '`.' );
	}
	if ( ndims > MAX_DIMS ) {
		throw new RangeError( 'invalid argument. Number of dimensions must not exceed ' + MAX_DIMS + ' due to stack limits. Value: `' + ndims + '`.' );
	}
	opts = {};
	opts.codegen = defaults.codegen;
	opts.mode = defaults.mode;
	if ( arguments.length > 2 ) {
		err = validate( opts, options );
		if ( err ) {
			throw err;
		}
	}
	if ( opts.submode === void 0 ) {
		opts.submode = [ opts.mode ];
	}
	// Create a lower-level base constructor:
	parent = baseCtor( dtype, ndims, opts );

	/**
	* ndarray constructor.
	*
	* @private
	* @constructor
	* @param {(ArrayLikeObject|TypedArray|Buffer)} buffer - data buffer
	* @param {NonNegativeIntegerArray} shape - array shape
	* @param {IntegerArray} strides - array strides
	* @param {NonNegativeInteger} offset - index offset
	* @param {string} order - specifies whether an array is row-major (C-style) or column-major (Fortran-style)
	* @throws {TypeError} `buffer` argument must be an array-like object, typed-array-like, or a Buffer
	* @throws {TypeError} `shape` argument must be an array-like object containing nonnegative integers
	* @throws {Error} `shape` argument length must equal the number of dimensions
	* @throws {TypeError} `strides` argument must be an array-like object containing integers
	* @throws {Error} `strides` argument length must equal the number of dimensions
	* @throws {TypeError} `offset` argument must be a nonnegative integer
	* @throws {TypeError} `order` argument must be a supported ndarray order
	* @throws {Error} `buffer` argument must be compatible with specified meta data
	* @returns {ndarray} ndarray instance
	*/
	function ndarray( buffer, shape, strides, offset, order ) {
		/* eslint-disable no-invalid-this */
		var sh;
		var st;
		if ( !(this instanceof ndarray) ) {
			return new ndarray( buffer, shape, strides, offset, order );
		}
		if (
			!isArrayLikeObject( buffer ) &&
			!isTypedArrayLike( buffer ) &&
			!isBuffer( buffer )
		) {
			throw new TypeError( 'invalid argument. `buffer` argument must be an array-like object, typed-array-like, or a Buffer. Value: `' + buffer + '`.' );
		}
		if ( !isNonNegativeIntegerArray( shape ) ) {
			throw new TypeError( 'invalid argument. `shape` argument must be an array-like object containing nonnegative integers. Value: `' + shape + '`.' );
		}
		if ( shape.length !== ndims ) {
			throw new Error( 'invalid argument. `shape` length must match the number of dimensions. Expected number of dimensions: ' + ndims + '. Shape length: ' + shape.length + '.' );
		}
		if ( !isIntegerArray( strides ) ) {
			throw new TypeError( 'invalid argument. `strides` argument must be an array-like object containing integers. Value: `' + strides + '`.' );
		}
		if ( strides.length !== ndims ) {
			throw new Error( 'invalid argument. `strides` length must match the number of dimensions. Expected number of dimensions: ' + ndims + '. Strides length: ' + strides.length + '.' );
		}
		if ( !isNonNegativeInteger( offset ) ) {
			throw new TypeError( 'invalid argument. `offset` argument must be a nonnegative integer. Value: `' + offset + '`.' );
		}
		if ( !isOrder( order ) ) {
			throw new TypeError( 'invalid argument. `order` argument must be a supported order. Value: `' + order + '`.' );
		}
		if ( !isBufferLengthCompatible( buffer.length, shape, strides, offset ) ) { // eslint-disable-line max-len
			throw new Error( 'invalid arguments. The input buffer is incompatible with the specified meta data. Ensure that the offset is valid with regard to the stride array and that the buffer has enough elements to satisfy the desired array shape.' );
		}
		// Copy `shape` and `strides` to prevent external mutation:
		sh = copy( shape, ndims );
		st = copy( strides, ndims );

		// Call the parent constructor:
		parent.call( this, buffer, sh, st, offset, order );

		// Cache references to the parent constructor and parent constructor methods:
		this._parent = parent;

		return this;

		/* eslint-enable no-invalid-this */
	}

	/**
	* Size (in bytes) of each array element (if known).
	*
	* @private
	* @name BYTES_PER_ELEMENT
	* @memberof ndarray
	* @type {(PositiveInteger|null)}
	*
	* @example
	* var nbytes = ndarray.BYTES_PER_ELEMENT;
	* // returns <number>
	*/
	setReadOnly( ndarray, 'BYTES_PER_ELEMENT', bytesPerElement( dtype ) );

	/**
	* Underlying data type.
	*
	* @private
	* @name dtype
	* @memberof ndarray
	* @type {string}
	*
	* @example
	* var dtype = ndarray.dtype;
	* // returns <string>
	*/
	setReadOnly( ndarray, 'dtype', dtype );

	/**
	* Number of dimensions.
	*
	* @private
	* @name ndims
	* @memberof ndarray
	* @type {PositiveInteger}
	*
	* @example
	* var ndims = ndarray.ndims;
	* // returns <number>
	*/
	setReadOnly( ndarray, 'ndims', ndims );

	// Inherit from the parent constructor:
	inherit( ndarray, parent );

	/**
	* Returns an array element.
	*
	* @private
	* @name get
	* @memberof ndarray.prototype
	* @type {Function}
	* @param {...integer} idx - indices
	* @returns {*} array element
	*
	* @example
	* var buffer = [ 1, 2, 3, 4, 5, 6 ];
	* var shape = [ 3, 2 ];
	* var strides = [ 2, 1 ];
	* var offset = 0;
	*
	* var x = ndarray( buffer, shape, strides, offset, 'row-major' );
	*
	* var v = x.get( 1, 1 );
	* // returns 4
	*/
	setReadOnly( ndarray.prototype, 'get', getValue( ndims, opts.codegen, opts.submode ) );

	/**
	* Returns an array element located at a specified linear index.
	*
	* @private
	* @name iget
	* @memberof ndarray.prototype
	* @type {Function}
	* @param {integer} idx - linear index
	* @returns {*} array element
	*
	* @example
	* var buffer = [ 1, 2, 3, 4, 5, 6 ];
	* var shape = [ 3, 2 ];
	* var strides = [ 2, 1 ];
	* var offset = 0;
	*
	* var x = ndarray( buffer, shape, strides, offset, 'row-major' );
	*
	* var v = x.iget( 3 );
	* // returns 4
	*/
	setReadOnly( ndarray.prototype, 'iget', igetValue( parent.prototype.iget, opts.mode ) );

	/**
	* Sets an array element.
	*
	* @private
	* @name set
	* @memberof ndarray.prototype
	* @type {Function}
	* @param {...integer} idx - indices
	* @param {*} v - value to set
	* @returns {ndarray} ndarray instance
	*
	* @example
	* var buffer = [ 1, 2, 3, 4, 5, 6 ];
	* var shape = [ 3, 2 ];
	* var strides = [ 2, 1 ];
	* var offset = 0;
	*
	* var x = ndarray( buffer, shape, strides, offset, 'row-major' );
	*
	* var v = x.get( 1, 1 );
	* // returns 4
	*
	* x.set( 1, 1, 10 );
	*
	* var b = x.data;
	* // returns [ 1, 2, 3, 10, 5, 6 ]
	*
	* v = x.get( 1, 1 );
	* // returns 10
	*/
	setReadOnly( ndarray.prototype, 'set', setValue( ndims, opts.codegen, opts.submode ) );

	/**
	* Sets an array element located at a specified linear index.
	*
	* @private
	* @name iset
	* @memberof ndarray.prototype
	* @type {Function}
	* @param {integer} idx - linear index
	* @param {*} v - value to set
	* @returns {ndarray} ndarray instance
	*
	* @example
	* var buffer = [ 1, 2, 3, 4, 5, 6 ];
	* var shape = [ 3, 2 ];
	* var strides = [ 2, 1 ];
	* var offset = 0;
	*
	* var x = ndarray( buffer, shape, strides, offset, 'row-major' );
	*
	* var v = x.iget( 3 );
	* // returns 4
	*
	* x.iset( 3, 10 );
	*
	* var b = x.data;
	* // returns [ 1, 2, 3, 10, 5, 6 ]
	*
	* v = x.iget( 3 );
	* // returns 10
	*/
	setReadOnly( ndarray.prototype, 'iset', isetValue( parent.prototype.iset, opts.mode ) );

	return ndarray;
}


// EXPORTS //

module.exports = ctor;
