/**
* @license Apache-2.0
*
* Copyright (c) 2020 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var isNumber = require( '@stdlib/assert/is-number' ).isPrimitive;
var isndarrayLike = require( '@stdlib/assert/is-ndarray-like' );
var isArrayLikeObject = require( '@stdlib/assert/is-array-like-object' );
var isSingleSegmentCompatible = require( '@stdlib/ndarray/base/assert/is-single-segment-compatible' );
var isFloat64Array = require( '@stdlib/assert/is-float64array' );
var isFloat32Array = require( '@stdlib/assert/is-float32array' );
var ndarray = require( '@stdlib/ndarray/memoized-ctor' );
var buffer = require( '@stdlib/ndarray/base/buffer' );
var shape2strides = require( '@stdlib/ndarray/base/shape2strides' );
var iterationOrder = require( '@stdlib/ndarray/base/iteration-order' );
var singletonDimensions = require( '@stdlib/ndarray/base/singleton-dimensions' );
var dtype = require( '@stdlib/ndarray/base/buffer-dtype' );
var maxViewBufferIndex = require( '@stdlib/ndarray/base/max-view-buffer-index' );
var minViewBufferIndex = require( '@stdlib/ndarray/base/min-view-buffer-index' );
var base = require( '@stdlib/math/base/special/abs' );
var dabs = require( '@stdlib/math/strided/special/dabs' );
var sabs = require( '@stdlib/math/strided/special/sabs' );
var gabs = require( '@stdlib/math/strided/special/abs' );


// MAIN //

/**
* Computes the absolute value.
*
* @param {(ndarray|ArrayLikeObject|number)} x - input value
* @throws {TypeError} must provide either an ndarray, array-like object, or number
* @returns {(ndarray|ArrayLikeObject|number)} results
*
* @example
* var y = abs( -1.0 );
* // returns 1.0
*
* @example
* var Float64Array = require( '@stdlib/array/float64' );
*
* var x = new Float64Array( [ 1.0, -1.0, 0.0 ] );
*
* var y = abs( x );
* // returns <Float64Array>[ 1.0, 1.0, 0.0 ]
*
* @example
* var array = require( '@stdlib/ndarray/array' );
*
* var x = array( [ [ 1.0, -2.0 ], [ -3.0, 4.0 ] ] );
* // returns <ndarray>
*
* var y = abs( x );
* // returns <ndarray>
*
* var v = y.get( 0, 1 );
* // 2.0
*/
function abs( x ) {
	var strides;
	var offset;
	var order;
	var ndims;
	var shape;
	var data;
	var ctor;
	var buf;
	var dt;
	var N;
	var s;
	var y;
	var f;
	var i;

	if ( isNumber( x ) ) {
		return base( x );
	}
	// TODO: add complex number support; should probably coincide with complex number array support

	if ( isndarrayLike( x ) ) {
		// Cache ndarray properties to avoid repeatedly calling ndarray accessors...
		N = x.length;
		ndims = x.ndims;
		shape = x.shape;
		strides = x.strides;
		offset = x.offset;
		order = x.order;
		data = x.data;
		dt = x.dtype;

		// Determine whether we can use a type-optimized implementation...
		if ( dt === 'float64' ) {
			f = dabs;
		} else if ( dt === 'float32' ) {
			f = sabs;
		} else {
			f = gabs;
		}
		// Create an output ndarray...
		ctor = ndarray( dt, ndims );
		buf = buffer( dt, N );
		y = ctor( buf, shape, shape2strides( shape, order ), 0, order );

		// Determine whether the ndarray is one-dimensional and thus readily translates to a one-dimensional strided array...
		if ( ndims === 1 ) {
			f.ndarray( N, data, strides[ 0 ], offset, buf, 1, 0 );
			return y;
		}
		// Determine whether the ndarray has only **one** non-singleton dimension (e.g., ndims=4, shape=[10,1,1,1]) so that we can treat the ndarray as being equivalent to a one-dimensional strided array...
		if ( singletonDimensions( shape ) === ndims-1 ) {
			// Get the stride for the non-singleton dimension...
			for ( i = 0; i < ndims; i++ ) {
				if ( shape[ i ] !== 1 ) {
					s = strides[ i ];
					break;
				}
			}
			f.ndarray( N, data, s, offset, buf, 1, 0 );
			return y;
		}
		// Determine whether we can ignore shape (and strides) and treat `x` as a linear strided array...
		s = iterationOrder( strides ); // +/-1
		if ( s !== 0 && isSingleSegmentCompatible( shape, strides, offset ) ) { // Note: equivalent to @stdlib/ndarray/base/assert/is-contiguous, but in-lined so we can retain iteration order
			if ( s === 1 ) {
				offset = minViewBufferIndex( shape, strides, offset );
			} else {
				offset = maxViewBufferIndex( shape, strides, offset );
			}
			f.ndarray( N, data, s, offset, buf, 1, 0 );
			return y;
		}
		// At this point, `x` is a non-contiguous n-dimensional array, so we cannot directly use lower-level strided array functionality...

		// TODO: consider cache oblivious iteration, rather than data copy...
		data = buffer( dt, N );
		for ( i = 0; i < N; i++ ) {
			data[ i ] = x.iget( i );
		}
		// The buffer copy is contiguous so we can now use lower-level strided array functionality...
		f( N, data, 1, buf, 1 );
		return y;
	}
	if ( !isArrayLikeObject( x ) ) {
		throw new TypeError( 'invalid argument. Must provide either an ndarray, array-like object, or number. Value: `' + x + '`.' );
	}
	N = x.length;
	dt = dtype( x ) || 'generic';

	// Create an output array...
	y = buffer( dt, N );

	// Determine whether we can use type-optimized implementations...
	if ( isFloat64Array( x ) ) {
		f = dabs;
	} else if ( isFloat32Array( x ) ) {
		f = sabs;
	} else {
		f = gabs;
	}
	f( N, x, 1, y, 1 );
	return y;
}


// EXPORTS //

module.exports = abs;
